# AI Behavior Guidelines for Emoji Linter Project

## Core Principles

### 1. Code Quality Standards
- **NO EMOJIS** in source code, comments, or console logs
- Emojis are ONLY allowed in:
  - Test fixtures (for testing emoji detection)
  - Documentation examples (showing usage)
  - The actual emoji patterns being detected
- Use clear, descriptive variable names instead of emojis
- Maintain professional code standards

### 2. Security First
- **NEVER** commit secrets, tokens, or API keys
- Always use GitHub token from action inputs, never hardcode
- Validate all inputs before processing
- Sanitize user inputs to prevent injection attacks
- Use parameterized operations for GitHub API calls

### 3. GitHub Action Best Practices
- Always use `@actions/core` for inputs/outputs
- Set proper exit codes with `core.setFailed()`
- Provide clear, actionable error messages
- Use `core.info()` for logging, not console.log
- Bundle with @vercel/ncc for distribution

### 4. Testing Requirements
- Write tests BEFORE implementation (TDD approach)
- Minimum 80% code coverage
- Test all emoji detection patterns
- Test all action modes (require, forbid, count)
- Include edge cases and error scenarios

### 5. Error Handling
- Fail fast with clear error messages
- Always catch and handle promise rejections
- Provide context in error messages
- Use try-catch blocks in async functions
- Set action as failed on any critical error

## Development Workflow

### Before Making Changes
1. Ensure you're on the correct branch
2. Read existing code to understand patterns
3. Check test coverage for the area you're modifying
4. Plan your implementation approach

### During Development
1. Follow existing code style and patterns
2. Write tests first (TDD)
3. Implement minimal code to pass tests
4. Refactor for clarity and performance
5. Document complex logic with comments

### Before Completion
1. Run all tests (`npm test`)
2. Check linting (`npm run lint`)
3. Build the action (`npm run build`)
4. Verify dist/index.js is updated
5. Test the action locally if possible

## File-Specific Guidelines

### action.yml
- This is the CRITICAL file for GitHub Actions
- Must be valid YAML
- Defines all inputs, outputs, and metadata
- Changes here affect how users consume the action

### src/index.js
- Entry point for the action
- Must handle all GitHub contexts properly
- Should be minimal - delegate to other modules
- Must catch all errors and fail gracefully

### src/linter.js
- Core business logic
- Should be pure functions where possible
- Must handle Unicode and shortcode emojis
- Should be thoroughly tested

### dist/index.js
- GENERATED FILE - never edit directly
- Must be rebuilt after any source changes
- Must be committed for action to work
- Generated by `npm run build`

## Common Pitfalls to Avoid

1. **Forgetting to build**: Always run `npm run build` after changes
2. **Not handling undefined**: GitHub context values can be undefined
3. **Assuming PR context**: Action can run on push events too
4. **Hardcoding values**: Use inputs for all configuration
5. **Silent failures**: Always report why something failed

## Decision Framework

When making technical decisions:

1. **Prioritize reliability** - The action must work consistently
2. **Keep it simple** - Avoid over-engineering
3. **Follow conventions** - Use standard GitHub Action patterns
4. **Think about users** - Make configuration intuitive
5. **Document choices** - Explain non-obvious decisions

## Validation Checklist

Before considering any task complete:

- [ ] Tests written and passing
- [ ] Code follows style guidelines
- [ ] No hardcoded values or secrets
- [ ] Error handling implemented
- [ ] Action builds successfully
- [ ] dist/index.js updated
- [ ] No console.log statements
- [ ] Using @actions/core for I/O
- [ ] Documentation updated if needed